using System;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace Bridge.Core.Unity.Editor
{
	public static class BridgeCoreNativeSourceSync
	{
		private const string DestRelativeDir = "Assets/Plugins/x86_64/BridgeCoreSource";

		[MenuItem("BridgeCore/Windows/Sync C++ Sources (for IL2CPP source plugin)")]
		public static void SyncSourcesForIl2Cpp()
		{
			if (!EnsureWindows())
				return;

			string projectRoot = Directory.GetParent(Application.dataPath).FullName;
			string repoRoot = FindRepoRoot(projectRoot);
			if (string.IsNullOrEmpty(repoRoot))
				return;

			string destDirAbs = Path.Combine(projectRoot, DestRelativeDir.Replace('/', Path.DirectorySeparatorChar));

			try
			{
				EditorUtility.DisplayProgressBar("BridgeCore", "Syncing native sources...", 0.2f);

				if (Directory.Exists(destDirAbs))
					Directory.Delete(destDirAbs, recursive: true);
				Directory.CreateDirectory(destDirAbs);

				// Unity 的 source plugin 在出包阶段会把 .cpp/.h 汇总到构建目录并“扁平化”路径，
				// 所以这里直接把所需最小文件集也扁平化到插件根目录，并在拷贝时改写 include 路径。
				//
				// 规则：把 <bridge/...> 统一改成 "xxx.h"，把相对路径 include 改成同名头文件。
				CopyFlatWithRewrite(repoRoot, destDirAbs);

				string generatedDir = Path.Combine(repoRoot, "Tests", "cpp", "generated");
				if (Directory.Exists(generatedDir))
				{
					// 注意：Unity 会把 Plugins 目录下的 .h 当作插件资源参与打包，
					// 同名文件会被判定为“插件冲突”并导致 Player Build 失败。
					// 因此这里保证每个生成头文件只拷贝一份（放到插件根目录，便于 include）。
					foreach (string file in Directory.GetFiles(generatedDir, "*.generated.h", SearchOption.TopDirectoryOnly))
					{
						string dst = Path.Combine(destDirAbs, Path.GetFileName(file));
						CopyTextWithIncludeRewrite(file, dst);
					}
				}

				File.WriteAllText(Path.Combine(destDirAbs, "README.txt"),
					"Auto-generated by BridgeCoreNativeSourceSync.\n" +
					"Delete this folder and re-sync if you change native sources.\n");

				AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
				Debug.Log("BridgeCore: synced native sources -> " + DestRelativeDir);
			}
			catch (Exception e)
			{
				Debug.LogError("BridgeCore: sync native sources failed:\n" + e);
			}
			finally
			{
				EditorUtility.ClearProgressBar();
			}
		}

		public static string GetDestRelativeDir() => DestRelativeDir;

		private static bool EnsureWindows()
		{
#if !UNITY_EDITOR_WIN
			EditorUtility.DisplayDialog("BridgeCore", "此菜单仅用于 Windows Editor。", "OK");
			return false;
#else
			return true;
#endif
		}

		private static void CopyFlatWithRewrite(string repoRoot, string destDirAbs)
		{
			var files = new[]
			{
				Path.Combine(repoRoot, "Core", "cpp", "include", "bridge", "bridge.h"),
				Path.Combine(repoRoot, "Core", "cpp", "include", "bridge", "runtime", "core_app.h"),
				Path.Combine(repoRoot, "Core", "cpp", "include", "bridge", "runtime", "core_context.h"),
				Path.Combine(repoRoot, "Core", "cpp", "include", "bridge", "runtime", "game_entry.h"),

				Path.Combine(repoRoot, "Core", "cpp", "src", "core", "command_stream.h"),
				Path.Combine(repoRoot, "Core", "cpp", "src", "core", "command_stream.cpp"),
				Path.Combine(repoRoot, "Core", "cpp", "src", "core", "core_instance.h"),
				Path.Combine(repoRoot, "Core", "cpp", "src", "core", "core_instance.cpp"),
				Path.Combine(repoRoot, "Core", "cpp", "src", "api", "bridge_api.cpp"),

				Path.Combine(repoRoot, "Tests", "cpp", "demo_game", "src", "demo_asset_app.h"),
				Path.Combine(repoRoot, "Tests", "cpp", "demo_game", "src", "demo_asset_app.cpp"),
				Path.Combine(repoRoot, "Tests", "cpp", "demo_game", "src", "game_entry.cpp"),
			};

			for (int i = 0; i < files.Length; i++)
			{
				string src = files[i];
				if (!File.Exists(src))
					throw new FileNotFoundException("Missing source file: " + src);

				string dst = Path.Combine(destDirAbs, Path.GetFileName(src));
				CopyTextWithIncludeRewrite(src, dst);
			}
		}

		private static void CopyTextWithIncludeRewrite(string src, string dst)
		{
			string ext = Path.GetExtension(src).ToLowerInvariant();
			if (!IsNativeSourceOrHeader(ext))
			{
				File.Copy(src, dst, overwrite: true);
				return;
			}

			string text = File.ReadAllText(src);

			// bridge public headers
			text = text.Replace("#include <bridge/bridge.h>", "#include \"bridge.h\"");
			text = text.Replace("#include <bridge/runtime/core_app.h>", "#include \"core_app.h\"");
			text = text.Replace("#include <bridge/runtime/core_context.h>", "#include \"core_context.h\"");
			text = text.Replace("#include <bridge/runtime/game_entry.h>", "#include \"game_entry.h\"");

			// bridge_api.cpp relative include (when copied out of src/api)
			text = text.Replace("#include \"../core/core_instance.h\"", "#include \"core_instance.h\"");

			File.WriteAllText(dst, text);
		}

		private static bool IsNativeSourceOrHeader(string ext)
		{
			if (string.IsNullOrEmpty(ext))
				return false;

			switch (ext.ToLowerInvariant())
			{
				case ".h":
				case ".hpp":
				case ".c":
				case ".cc":
				case ".cpp":
				case ".m":
				case ".mm":
					return true;
				default:
					return false;
			}
		}

		private static string FindRepoRoot(string startDir)
		{
			string dir = startDir;
			for (int i = 0; i < 12; i++)
			{
				if (File.Exists(Path.Combine(dir, "CMakeLists.txt")) &&
				    Directory.Exists(Path.Combine(dir, "Core")))
					return dir;

				var parent = Directory.GetParent(dir);
				if (parent == null)
					break;
				dir = parent.FullName;
			}

			EditorUtility.DisplayDialog("BridgeCore", "无法定位仓库根目录。起始目录：" + startDir, "OK");
			return string.Empty;
		}
	}
}
